"""
Visualizer Module: Generates an HTML report comparing Human vs. LLM annotations.
"""
import os
import html


class HTMLVisualizer:
    def __init__(self):
        # Part 1: HTML Header & CSS
        self.header = """<!DOCTYPE html>
<html>
<head>
    <title>C3PA Annotation Audit</title>
    <style>
        body { font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; padding: 20px; max-width: 1200px; margin: auto; background-color: #f9f9f9; }
        h1 { border-bottom: 2px solid #333; padding-bottom: 10px; }
        h2 { background-color: #e9ecef; padding: 10px; border-left: 5px solid #007bff; margin-top: 30px; }

        .legend { background: #fff; padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #ddd; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .legend span { display: inline-block; padding: 4px 8px; border-radius: 4px; margin-right: 10px; font-weight: bold; font-size: 0.9em; }

        /* Table Styles */
        table { width: 100%; border-collapse: collapse; margin-bottom: 10px; background: #fff; table-layout: fixed; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        th, td { padding: 12px; border: 1px solid #dee2e6; vertical-align: top; word-wrap: break-word; overflow-wrap: break-word; }

        /* Column Headers */
        th.human-col { background-color: #d4edda; color: #155724; width: 50%; }
        th.llm-col { background-color: #f8d7da; color: #721c24; width: 50%; }

        /* Cell Content */
        .human-text { white-space: pre-wrap; font-family: Consolas, "Courier New", monospace; font-size: 13px; color: #155724; }
        .llm-text { white-space: pre-wrap; font-family: Consolas, "Courier New", monospace; font-size: 13px; color: #721c24; }

        /* Match Highlighting */
        tr.match { background-color: #fff3cd; }
        tr.match td { border-color: #ffeeba; }

        .empty-msg { color: #6c757d; font-style: italic; text-align: center; padding: 20px; }
    </style>
</head>
<body>
    <h1>C3PA vs LLM Audit Report</h1>

    <div class="legend">
        <strong>Legend:</strong><br><br>
        <span style="background:#d4edda; color:#155724">Green Column</span> Human Ground Truth (C3PA)<br>
        <span style="background:#f8d7da; color:#721c24">Red Column</span> LLM Prediction<br>
        <span style="background:#fff3cd; color:#856404">Yellow Row</span> <strong>MATCH</strong> (Approximate Text Overlap)
    </div>
"""

        # Part 3: Footer
        self.footer = """
    <div style="margin-top: 50px; color: #ccc; text-align: center; font-size: 0.8em;">
        Generated by C3PA Auditor Pipeline
    </div>
</body>
</html>
"""

    def generate_report(self, policy_id, full_text, human_anns, llm_anns, filename="audit_report.html"):
        """
        Creates the HTML file by concatenating strings (No .replace() used).
        """
        # Build the body content
        content_html = f"<h3>Policy ID: {policy_id}</h3>"

        # Collect all unique labels
        human_labels = set(h['label'] for h in human_anns)
        llm_labels = set(l['label'] for l in llm_anns)
        all_labels = sorted(list(human_labels.union(llm_labels)))

        if not all_labels:
            content_html += "<div class='empty-msg'>No annotations found from either Human or LLM.</div>"

        count_sections = 0

        for label in all_labels:
            h_texts = [h['text'] for h in human_anns if h['label'] == label]
            l_texts = [l['text'] for l in llm_anns if l['label'] == label]

            # Skip if both are empty (shouldn't happen due to loop logic, but safe check)
            if not h_texts and not l_texts:
                continue

            count_sections += 1
            content_html += f"<h2>{html.escape(label)}</h2>"

            content_html += "<table>"
            content_html += "<thead><tr><th class='human-col'>Human (C3PA)</th><th class='llm-col'>LLM Prediction</th></tr></thead>"
            content_html += "<tbody>"

            max_len = max(len(h_texts), len(l_texts))

            for i in range(max_len):
                h_txt = h_texts[i] if i < len(h_texts) else ""
                l_txt = l_texts[i] if i < len(l_texts) else ""

                # Determine Match Status for coloring
                row_class = ""
                if h_txt and l_txt:
                    # Check for simple overlap
                    if h_txt in l_txt or l_txt in h_txt:
                        row_class = "match"
                    else:
                        # Jaccard fallback check
                        iou = self._calculate_iou(h_txt, l_txt)
                        if iou > 0.1:  # Loose threshold for visual highlighting
                            row_class = "match"

                content_html += f"<tr class='{row_class}'>"
                content_html += f"<td><div class='human-text'>{html.escape(h_txt)}</div></td>"
                content_html += f"<td><div class='llm-text'>{html.escape(l_txt)}</div></td>"
                content_html += "</tr>"

            content_html += "</tbody></table>"

        # Combine all parts
        final_html = self.header + content_html + self.footer

        # Write to file
        try:
            with open(filename, "w", encoding="utf-8") as f:
                f.write(final_html)
            # Debug print to confirm content was generated
            print(f"     [Visual] Generated report with {count_sections} label sections.")
        except Exception as e:
            print(f"     [Visual] ERROR writing file: {e}")

    def _calculate_iou(self, text_a, text_b):
        set_a = set(str(text_a).lower().split())
        set_b = set(str(text_b).lower().split())
        if not set_a or not set_b: return 0.0
        return len(set_a.intersection(set_b)) / len(set_a.union(set_b))